# Newton Physics Engine - AI Coding Instructions

## Project Overview
Newton is a GPU-accelerated physics simulation engine for robotics, built on NVIDIA Warp and MuJoCo. It emphasizes differentiability, OpenUSD support, and high-performance GPU computation.

## Architecture & Core Concepts
- **Public vs Internal**: 
  - Public API is exposed in `newton/__init__.py`.
  - Implementation details reside in `newton/_src/`.
  - **Rule**: Modify `_src` for implementation, but ensure public features are exposed in `__init__.py`.
- **Simulation Data Model**:
  - `Model` (`newton/_src/sim/model.py`): Static simulation description (bodies, joints, shapes). Constructed via `ModelBuilder`.
  - `State`: Dynamic simulation state (positions `q`, velocities `qd`).
  - `Control`: Control inputs (forces, target positions).
  - `Contacts`: Collision/contact information generated by `model.collide()`.
- **Attributes System**:
  - `Model` uses `AttributeNamespace` for hierarchical custom attributes.
  - Attributes are managed via `ModelAttributeFrequency` (e.g., per-body, per-joint) and `ModelAttributeAssignment` (owner object).
- **Backends**: 
  - Kernels written in `warp-lang`.
  - Physics backend leverages `mujoco-warp`.

## Development Workflow
- **Package Manager**: Use `uv` for all operations.
  - **Run Example**: `uv run -m newton.examples <example_name>` (e.g., `basic_pendulum`).
  - **Run Tests**: `uv run -m unittest discover newton/tests` or `uv run -m unittest newton/tests/test_api.py`.
  - **Linting**: `uv run ruff check .`
  - **Formatting**: `uv run ruff format .`

## Coding Standards & Patterns
- **Type Hints**: Use strict type hints. The project uses `basedpyright`.
- **Warp Kernels**:
  - **Explicit Casting**: Warp kernels (`@wp.kernel`) require explicit casting like `float(val)` or `int(val)`.
  - **Linter Ignores**: Do NOT remove these casts. `ruff` is configured to ignore `UP018` and `RUF046` for this reason.
- **ModelBuilder Parity**:
  - `ModelBuilder` methods (e.g., `add_urdf`) often wrap standalone importer functions (e.g., `parse_urdf`).
  - **Strict Requirement**: Ensure exact signature and docstring parity between the builder method and the underlying function.
  - **Verification**: See `newton/tests/test_api.py` which enforces this.
- **Imports**:
  - Use absolute imports for `newton` packages (e.g., `from newton._src.core import ...`).
  - Avoid circular imports by carefully structuring `_src` submodules.

## Testing
- **Framework**: `unittest`.
- **Location**: `newton/tests/`.
- **Patterns**:
  - **API Consistency**: Tests check signature parity between builders and importers.
  - **Simulation Correctness**: Tests verify physical behaviors (e.g., energy conservation, collision).

## Common Tasks
- **Adding an Example**: 
  - Place in `newton/examples/`.
  - Follow `newton/examples/basic/example_basic_pendulum.py` pattern:
    1. Setup `ModelBuilder`.
    2. Build model (bodies, joints, shapes).
    3. Finalize model.
    4. Initialize `Solver` (e.g., `SolverXPBD`).
    5. Create `State` and `Control`.
    6. Run simulation loop with `viewer`.
- **Extending the Model**:
  1. Update `Model` class in `newton/_src/sim/model.py`.
  2. Update `ModelBuilder` to support the new feature.
  3. Add relevant tests in `newton/tests/`.

## Key Files
- `pyproject.toml`: Dependencies, `ruff`, and `uv` configuration.
- `newton/__init__.py`: Public API definition.
- `newton/_src/sim/model.py`: Core `Model` class definition.
- `newton/examples/`: Reference implementations.
